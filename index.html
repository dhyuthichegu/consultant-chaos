<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Analyst's Memory</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --ui-bg: #34495e;
            --text-color: #ecf0f1;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 8px solid #34495e;
            border-radius: 10px;
            background-color: #7f8c8d; /* Floor color */
        }

        canvas {
            display: block;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            display: inline-block;
            pointer-events: auto;
        }

        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .modal {
            background: white;
            color: #333;
            padding: 40px;
            border-radius: 8px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .hidden { display: none !important; }

        h1 { margin-top: 0; color: #2c3e50; }
        h2 { color: #c0392b; }
        
        .btn {
            background: #2980b9;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            font-weight: bold;
            transition: 0.2s;
        }
        .btn:hover { transform: scale(1.05); background: #3498db; }
        .btn-red { background: #c0392b; }

        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
            text-align: left;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 18px;
            padding: 5px;
            background: #eee;
            border-radius: 4px;
        }
        .color-box {
            width: 25px;
            height: 25px;
            margin-right: 10px;
            border: 2px solid #333;
        }

        #timer-big {
            font-size: 60px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="650"></canvas>

        <div id="ui-layer">
            <div style="display: flex; justify-content: space-between;">
                <div class="hud-panel">üèÜ Score: <span id="score">0</span></div>
                <div class="hud-panel">‚ù§Ô∏è Patience: <span id="lives">100%</span></div>
            </div>
            <div style="text-align: center;">
                <div id="interaction-prompt" class="hud-panel hidden">PRESS [SPACE] TO GRAB</div>
            </div>
        </div>

        <div id="screens">
            <!-- Start Screen -->
            <div id="start-screen" class="modal">
                <h1>The Analyst's Memory</h1>
                <p>Welcome to the Firm. We value <strong>attention to detail</strong>.</p>
                <p><strong>HOW TO PLAY:</strong></p>
                <ul style="text-align: left; margin: 20px 40px;">
                    <li>You have <strong>20 SECONDS</strong> to memorize where the files are kept.</li>
                    <li>After the timer, the labels disappear!</li>
                    <li>Clients will ask for files (e.g., "Deck", "Model").</li>
                    <li>Run to the correct colored cabinet and press <strong>SPACE</strong> to grab the file.</li>
                    <li>Run back to the client and press <strong>SPACE</strong> to deliver.</li>
                </ul>
                <button class="btn" onclick="startMemoryPhase()">START INTERNSHIP</button>
            </div>

            <!-- Memory Phase Screen (Overlay) -->
            <div id="memory-screen" class="modal hidden" style="background: rgba(0,0,0,0.8); color: white; width: 100%; height: 100%; max-width: none; border-radius: 0;">
                <h1>MEMORIZE THE LOCATIONS!</h1>
                <div id="timer-big">20</div>
                <p>Look at the office layout below.</p>
                <div id="legend-display" class="legend-grid" style="background: rgba(255,255,255,0.9); padding: 20px; border-radius: 10px; color: black; max-width: 500px; margin: 20px auto;">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over-screen" class="modal hidden">
                <h2>YOU'RE FIRED</h2>
                <p>You forgot where the files were, or you were too slow.</p>
                <p>Final Score: <span id="final-score">0</span></p>
                <button class="btn btn-red" onclick="location.reload()">RE-APPLY (Try Again)</button>
            </div>
        </div>
    </div>

<script>
    /** 
     * THE ANALYST'S MEMORY
     * A memory + movement arcade game.
     */

    // --- CONFIGURATION ---
    const TASKS = [
        { id: 'deck', name: 'Pitch Deck', icon: 'üìä', color: '#e74c3c' }, // Red
        { id: 'model', name: 'Financial Model', icon: 'üìâ', color: '#2ecc71' }, // Green
        { id: 'legal', name: 'Legal Contract', icon: '‚öñÔ∏è', color: '#f1c40f' }, // Yellow
        { id: 'research', name: 'User Research', icon: 'üîç', color: '#9b59b6' }, // Purple
        { id: 'tech', name: 'Tech Stack', icon: 'üíª', color: '#3498db' }, // Blue
        { id: 'coffee', name: 'Coffee Run', icon: '‚òï', color: '#e67e22' } // Orange
    ];

    const CANVAS_WIDTH = 900;
    const CANVAS_HEIGHT = 650;
    const PLAYER_SPEED = 6;

    // --- STATE ---
    let canvas, ctx;
    let gameState = 'START'; // START, MEMORIZE, PLAYING, GAMEOVER
    let frame = 0;
    let score = 0;
    let globalPatience = 100;
    let memoryTimer = 20;
    let mapConfiguration = []; // Stores which cabinet holds which task

    // Entities
    let player = { x: 450, y: 500, w: 40, h: 40, holding: null, frame: 0, dir: 1 };
    let cabinets = [];
    let clients = [];
    let particles = [];
    
    // Inputs
    const keys = { w: false, a: false, s: false, d: false, space: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
    let spaceLocked = false; // Prevent holding space spam

    // --- INITIALIZATION ---
    window.onload = function() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        
        // Listeners
        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true;
            if(e.code === 'Space') keys['space'] = true;
        });
        window.addEventListener('keyup', (e) => {
            if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false;
            if(e.code === 'Space') { keys['space'] = false; spaceLocked = false; }
        });

        // Initial Draw to show background
        draw();
    };

    function startMemoryPhase() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('memory-screen').classList.remove('hidden');
        
        // 1. Randomize Cabinet Locations
        // We create a layout of 2 rows of 3 cabinets
        cabinets = [];
        let shuffledTasks = [...TASKS].sort(() => 0.5 - Math.random());
        mapConfiguration = shuffledTasks;

        // Row 1 (Top)
        for(let i=0; i<3; i++) {
            cabinets.push({ x: 150 + (i * 250), y: 100, w: 80, h: 100, task: shuffledTasks[i] });
        }
        // Row 2 (Middle)
        for(let i=0; i<3; i++) {
            cabinets.push({ x: 150 + (i * 250), y: 300, w: 80, h: 100, task: shuffledTasks[i+3] });
        }

        // 2. Populate Legend for User
        const legendDiv = document.getElementById('legend-display');
        legendDiv.innerHTML = '';
        shuffledTasks.forEach(t => {
            legendDiv.innerHTML += `
                <div class="legend-item">
                    <div class="color-box" style="background:${t.color}"></div>
                    <span>= ${t.name} ${t.icon}</span>
                </div>
            `;
        });

        gameState = 'MEMORIZE';
        gameLoop();

        // 3. Start Timer
        let interval = setInterval(() => {
            if(gameState !== 'MEMORIZE') { clearInterval(interval); return; }
            memoryTimer--;
            document.getElementById('timer-big').innerText = memoryTimer;
            if(memoryTimer <= 0) {
                clearInterval(interval);
                startGameplay();
            }
        }, 1000);
    }

    function startGameplay() {
        document.getElementById('memory-screen').classList.add('hidden');
        gameState = 'PLAYING';
        globalPatience = 100;
        score = 0;
        clients = [];
        
        // Spawn first client immediately
        spawnClient();
    }

    // --- GAME LOOP ---
    function gameLoop() {
        if(gameState === 'GAMEOVER') return;

        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        frame++;

        // 1. Movement
        let dx = 0; let dy = 0;
        if (keys['w'] || keys['ArrowUp']) dy = -PLAYER_SPEED;
        if (keys['s'] || keys['ArrowDown']) dy = PLAYER_SPEED;
        if (keys['a'] || keys['ArrowLeft']) dx = -PLAYER_SPEED;
        if (keys['d'] || keys['ArrowRight']) dx = PLAYER_SPEED;

        // Normalize diagonal
        if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }

        // Wall collisions (Simple bounds)
        if (player.x + dx > 0 && player.x + dx < CANVAS_WIDTH - player.w) player.x += dx;
        if (player.y + dy > 150 && player.y + dy < CANVAS_HEIGHT - player.h) player.y += dy; // Keep below reception wall

        // Animation state
        if (dx !== 0 || dy !== 0) player.frame += 0.2;

        // 2. Client Spawning logic
        if (gameState === 'PLAYING') {
            // Difficulty increases with score
            let spawnRate = Math.max(100, 300 - (score * 5));
            if (frame % spawnRate === 0 && clients.length < 4) {
                spawnClient();
            }

            // Client Patience
            clients.forEach(c => {
                c.patience -= 0.05 + (score * 0.001); // Gets harder
                if (c.patience <= 0) {
                    globalPatience -= 20; // Big hit
                    c.dead = true;
                    spawnFloatingText(c.x, c.y, "üò° LEFT!", "red");
                }
            });
            clients = clients.filter(c => !c.dead);

            // Game Over Check
            if (globalPatience <= 0) {
                globalPatience = 0;
                gameState = 'GAMEOVER';
                document.getElementById('final-score').innerText = score;
                document.getElementById('game-over-screen').classList.remove('hidden');
            }
            document.getElementById('lives').innerText = Math.floor(globalPatience) + "%";
            document.getElementById('score').innerText = score;
        }

        // 3. Interactions
        checkInteractions();
    }

    function spawnClient() {
        // Pick a random task
        const randomTask = TASKS[Math.floor(Math.random() * TASKS.length)];
        
        // Clients line up at the bottom "reception" area
        clients.push({
            x: 100 + (clients.length * 150),
            y: CANVAS_HEIGHT - 80,
            w: 50, h: 80,
            task: randomTask,
            patience: 100,
            color: `hsl(${Math.random()*360}, 60%, 70%)` // Random shirt color
        });
    }

    function checkInteractions() {
        const dist = 60; // Interaction radius
        let nearSomething = false;

        // Check Cabinets
        cabinets.forEach(cab => {
            if (getDistance(player, cab) < dist) {
                nearSomething = true;
                if (keys['space'] && !spaceLocked && !player.holding) {
                    // Grab item
                    player.holding = cab.task;
                    spaceLocked = true;
                    spawnFloatingText(player.x, player.y, "Got " + cab.task.name + "!", "#fff");
                }
            }
        });

        // Check Clients
        clients.forEach((cli, index) => {
            if (getDistance(player, cli) < dist) {
                nearSomething = true;
                if (keys['space'] && !spaceLocked && player.holding) {
                    spaceLocked = true;
                    if (player.holding.id === cli.task.id) {
                        // Success!
                        score += 10;
                        globalPatience = Math.min(100, globalPatience + 5);
                        spawnFloatingText(cli.x, cli.y, "THANKS! +10", "#2ecc71");
                        clients.splice(index, 1);
                        player.holding = null;
                    } else {
                        // Wrong item
                        spawnFloatingText(cli.x, cli.y, "WRONG FILE!", "red");
                        globalPatience -= 5;
                    }
                }
            }
        });

        const prompt = document.getElementById('interaction-prompt');
        if (nearSomething) prompt.classList.remove('hidden');
        else prompt.classList.add('hidden');
    }

    function getDistance(obj1, obj2) {
        let cx1 = obj1.x + obj1.w/2;
        let cy1 = obj1.y + obj1.h/2;
        let cx2 = obj2.x + obj2.w/2;
        let cy2 = obj2.y + obj2.h/2;
        return Math.sqrt(Math.pow(cx2-cx1, 2) + Math.pow(cy2-cy1, 2));
    }

    function spawnFloatingText(x, y, text, color) {
        particles.push({x, y, text, color, life: 60});
    }

    // --- DRAWING ---
    function draw() {
        // Clear
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Floor Grid
        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.lineWidth = 2;
        for(let i=0; i<CANVAS_WIDTH; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,CANVAS_HEIGHT); ctx.stroke(); }
        for(let i=0; i<CANVAS_HEIGHT; i+=50) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(CANVAS_WIDTH,i); ctx.stroke(); }

        // Draw Walls (Top area)
        ctx.fillStyle = "#34495e";
        ctx.fillRect(0, 0, CANVAS_WIDTH, 50);

        // Draw Cabinets
        cabinets.forEach(cab => {
            // Cabinet Body
            ctx.fillStyle = cab.task.color;
            ctx.fillRect(cab.x, cab.y, cab.w, cab.h);
            
            // Details (Drawers)
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.fillRect(cab.x + 10, cab.y + 10, cab.w - 20, 20); // Drawer 1
            ctx.fillRect(cab.x + 10, cab.y + 40, cab.w - 20, 20); // Drawer 2
            ctx.fillRect(cab.x + 10, cab.y + 70, cab.w - 20, 20); // Drawer 3

            // If in Memory Phase, show the icon/label
            if (gameState === 'MEMORIZE') {
                ctx.fillStyle = "white";
                ctx.font = "30px Arial";
                ctx.fillText(cab.task.icon, cab.x + 25, cab.y - 10);
                
                ctx.font = "14px Arial";
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.fillText(cab.task.name, cab.x + cab.w/2, cab.y + cab.h + 20);
            }
        });

        // Draw Reception Desk Area (Bottom)
        ctx.fillStyle = "#bdc3c7";
        ctx.fillRect(0, CANVAS_HEIGHT - 100, CANVAS_WIDTH, 10); // Countertop

        // Draw Clients
        clients.forEach(c => {
            // Bobbing animation
            let bob = Math.sin(frame * 0.1) * 3;
            
            // Body
            ctx.fillStyle = c.color;
            ctx.fillRect(c.x, c.y + bob, c.w, c.h);
            
            // Head
            ctx.fillStyle = "#ffccaa";
            ctx.fillRect(c.x + 10, c.y - 30 + bob, 30, 30);
            
            // Thought Bubble
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.ellipse(c.x + 25, c.y - 60 + bob, 30, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.stroke();
            
            // Icon in bubble
            ctx.fillStyle = "black";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText(c.task.icon, c.x + 25, c.y - 53 + bob);

            // Patience Bar
            ctx.fillStyle = "red";
            ctx.fillRect(c.x, c.y + c.h + 10, c.w, 5);
            ctx.fillStyle = "#2ecc71";
            ctx.fillRect(c.x, c.y + c.h + 10, c.w * (c.patience / 100), 5);
        });

        // Draw Player
        let pBob = Math.sin(player.frame) * 5;
        
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(player.x + player.w/2, player.y + player.h - 5, 15, 5, 0, 0, Math.PI*2);
        ctx.fill();

        // Body
        ctx.fillStyle = "#333"; // Suit
        ctx.fillRect(player.x, player.y + pBob, player.w, player.h);
        
        // Head
        ctx.fillStyle = "#ffccaa";
        ctx.fillRect(player.x + 5, player.y - 25 + pBob, 30, 25);

        // Holding Item?
        if (player.holding) {
            ctx.fillStyle = player.holding.color;
            ctx.fillRect(player.x + 10, player.y - 45 + pBob, 20, 25); // File folder
            ctx.fillStyle = "white";
            ctx.font = "14px Arial";
            ctx.fillText(player.holding.icon, player.x + 20, player.y - 35 + pBob);
        }

        // Particles
        particles.forEach((p, i) => {
            ctx.fillStyle = p.color;
            ctx.font = "bold 20px Arial";
            ctx.fillText(p.text, p.x, p.y);
            p.y -= 1;
            p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        });
    }

</script>
</body>
</html>