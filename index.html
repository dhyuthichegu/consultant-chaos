<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Analyst: Meme Edition</title>
    <style>
        :root {
            --bg-color: #74b9ff;
            --floor-color: #dfe6e9;
            --wall-color: #b2bec3;
        }
        
        body {
            font-family: 'Verdana', sans-serif;
            background-color: #2d3436;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 0 10px #000;
            border-radius: 20px;
            overflow: hidden;
            background: var(--floor-color);
            width: 900px;
            height: 650px;
        }

        canvas { display: block; }

        /* HUD */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
        }

        .hud-pill {
            background: white;
            border: 4px solid black;
            padding: 10px 25px;
            border-radius: 50px;
            font-weight: 900;
            font-size: 24px;
            box-shadow: 6px 6px 0 rgba(0,0,0,0.3);
            text-transform: uppercase;
        }

        /* Screens */
        #screens {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .modal {
            background: white;
            border: 6px solid black;
            border-radius: 25px;
            padding: 50px;
            text-align: center;
            box-shadow: 20px 20px 0 rgba(0,0,0,0.4);
            max-width: 600px;
        }

        .hidden { display: none !important; }

        h1 { margin: 0 0 15px 0; font-size: 48px; -webkit-text-stroke: 2px black; color: #ffeb3b; text-shadow: 4px 4px 0 #000; }
        p { font-size: 20px; font-weight: bold; margin: 10px 0; }
        
        .btn {
            background: #00cec9;
            border: 4px solid black;
            padding: 20px 50px;
            font-size: 28px;
            font-weight: 900;
            cursor: pointer;
            border-radius: 15px;
            margin-top: 30px;
            box-shadow: 8px 8px 0 black;
            transition: transform 0.1s;
        }
        .btn:active { transform: translate(5px, 5px); box-shadow: none; }
        .btn:hover { background: #81ecec; }

        /* Timer & Legend */
        #timer-big { font-size: 100px; font-weight: 900; -webkit-text-stroke: 4px black; color: white; margin: 20px 0; text-shadow: 8px 8px 0 black;}
        
        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            background: white;
            padding: 20px;
            border: 4px solid black;
            border-radius: 15px;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.5);
        }
        .legend-item { display: flex; align-items: center; font-size: 20px; font-weight: bold; }
        .color-dot { width: 30px; height: 30px; border-radius: 50%; border: 3px solid black; margin-right: 15px; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="650"></canvas>

        <div id="ui-layer">
            <div class="hud-pill" style="color:#0984e3">Q<span id="level-display">1</span></div>
            <div class="hud-pill" style="color:#6c5ce7">Goal: <span id="served-display">0</span>/<span id="goal-display">2</span></div>
            <div class="hud-pill" style="color:#d63031">‚ù§Ô∏è <span id="lives-display">100%</span></div>
        </div>

        <div id="screens">
            <!-- Start Screen -->
            <div id="start-screen" class="modal">
                <h1>THE ANALYST</h1>
                <p>Survive the corporate ladder.</p>
                <div style="background:#dfe6e9; padding:20px; border:3px solid black; border-radius:10px; margin:20px 0; text-align:left;">
                    <p>üß† <strong>MEMORIZE</strong> the cabinet locations.</p>
                    <p>üèÉ <strong>RUN</strong> to fetch the files.</p>
                    <p>üê¢ <strong>Q1 IS SLOW.</strong> Take your time.</p>
                    <p>üîä <strong>SOUND ON</strong> for meme fx.</p>
                </div>
                <button class="btn" onclick="startMemoryPhase()">HIRE ME</button>
            </div>

            <!-- Memory Phase -->
            <div id="memory-screen" class="modal hidden" style="background: rgba(0,0,0,0.9); width:100%; height:100%; max-width:none; border:none; border-radius:0;">
                <h1 style="color:white">MEMORIZE!</h1>
                <div id="timer-big">20</div>
                <div id="legend-display" class="legend-grid"></div>
            </div>

            <!-- Level Complete -->
            <div id="level-screen" class="modal hidden">
                <h1 style="color: #55efc4;">PROMOTED!</h1>
                <p>Performance: <span style="color:#00b894">EXCELLENT</span></p>
                <p>Prepare for the next quarter.</p>
                <button class="btn" onclick="nextLevel()">NEXT Q</button>
            </div>

            <!-- Game Over -->
            <div id="game-over-screen" class="modal hidden">
                <h1 style="color: #ff7675;">FIRED</h1>
                <p>Pack your desk.</p>
                <button class="btn" onclick="location.reload()">RE-APPLY</button>
            </div>
        </div>
    </div>

<script>
    // --- AUDIO SYSTEM (MEME SYNTH) ---
    const Audio = {
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        playTone: function(freq, type, duration, vol=0.1) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        vineBoom: function() {
            // Low thud
            this.playTone(60, 'sawtooth', 0.5, 0.3);
            this.playTone(40, 'sine', 0.8, 0.5);
        },
        yippee: function() {
            // High happy noise
            this.playTone(800, 'sine', 0.1, 0.1);
            setTimeout(() => this.playTone(1200, 'sine', 0.2, 0.1), 100);
        },
        wompWomp: function() {
            this.playTone(150, 'triangle', 0.3, 0.2);
            setTimeout(() => this.playTone(100, 'triangle', 0.6, 0.2), 300);
        },
        yeet: function() {
            // Slide whistle effect
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(400, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(1000, this.ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.3);
        }
    };

    // --- CONSTANTS ---
    const TASKS = [
        { id: 'deck', name: 'Deck', icon: 'üìä', color: '#ff7675' },
        { id: 'model', name: 'Model', icon: 'üìâ', color: '#55efc4' },
        { id: 'legal', name: 'Legal', icon: 'üìú', color: '#ffeaa7' },
        { id: 'coffee', name: 'Coffee', icon: '‚òï', color: '#fab1a0' },
        { id: 'tech', name: 'IT', icon: 'üíª', color: '#74b9ff' },
        { id: 'lunch', name: 'Lunch', icon: 'üçî', color: '#a29bfe' }
    ];

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- STATE ---
    let state = {
        phase: 'START',
        level: 1,
        score: 0,
        goal: 2,
        patience: 100,
        map: [],
        frame: 0
    };

    let player = { x: 450, y: 350, w: 40, h: 50, holding: null, frame: 0, faceDir: 1 };
    let clients = [];
    let particles = [];
    
    // Environment
    const deskY = 500;
    const trashBin = { x: 820, y: 480, w: 50, h: 60 };

    // Inputs
    const keys = { w: false, a: false, s: false, d: false, space: false };
    let spaceLocked = false;

    window.addEventListener('keydown', e => {
        if(e.code === 'Space') keys.space = true;
        if(e.key === 'w' || e.key === 'ArrowUp') keys.w = true;
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = true;
        if(e.key === 's' || e.key === 'ArrowDown') keys.s = true;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = true;
        
        // Resume Audio Context on interaction
        if (Audio.ctx.state === 'suspended') Audio.ctx.resume();
    });
    window.addEventListener('keyup', e => {
        if(e.code === 'Space') { keys.space = false; spaceLocked = false; }
        if(e.key === 'w' || e.key === 'ArrowUp') keys.w = false;
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = false;
        if(e.key === 's' || e.key === 'ArrowDown') keys.s = false;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = false;
    });

    // --- GAME LOOP ---
    function init() { requestAnimationFrame(loop); }

    function startMemoryPhase() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('memory-screen').classList.remove('hidden');

        // Generate Map (Randomized)
        let shuffled = [...TASKS].sort(() => Math.random() - 0.5);
        state.map = [];
        
        // Row 1 (Top)
        for(let i=0; i<3; i++) state.map.push({ x: 120 + (i * 250), y: 100, w: 100, h: 120, task: shuffled[i] });
        // Row 2 (Middle)
        for(let i=0; i<3; i++) state.map.push({ x: 120 + (i * 250), y: 300, w: 100, h: 120, task: shuffled[i+3] });

        // Legend
        const lg = document.getElementById('legend-display');
        lg.innerHTML = '';
        shuffled.forEach(t => {
            lg.innerHTML += `<div class="legend-item"><div class="color-dot" style="background:${t.color}"></div>${t.name}</div>`;
        });

        // Timer
        let t = 20;
        state.phase = 'MEMORIZE';
        let timerEl = document.getElementById('timer-big');
        let intv = setInterval(() => {
            if(state.phase !== 'MEMORIZE') { clearInterval(intv); return; }
            t--;
            timerEl.innerText = t;
            if(t <= 0) {
                clearInterval(intv);
                startLevel();
            }
        }, 1000);
    }

    function startLevel() {
        document.getElementById('memory-screen').classList.add('hidden');
        document.getElementById('level-screen').classList.add('hidden');
        state.phase = 'PLAYING';
        state.score = 0;
        state.patience = 100;
        player.holding = null;
        clients = [];
        
        // Difficulty Scaling
        // Level 1: 45s wait. Level 2: 15s wait. Level 3: 8s wait.
        state.goal = 1 + state.level; 
        
        updateHUD();
        spawnClient(); // First one is free
    }

    function nextLevel() {
        state.level++;
        startLevel();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        if (state.phase !== 'PLAYING') return;
        state.frame++;

        // 1. Movement
        let dx = 0, dy = 0;
        const speed = 6;
        if(keys.w) dy -= speed;
        if(keys.s) dy += speed;
        if(keys.a) dx -= speed;
        if(keys.d) dx += speed;
        
        player.x += dx; player.y += dy;
        
        // Bounds (Room Walls)
        player.x = Math.max(20, Math.min(840, player.x));
        player.y = Math.max(50, Math.min(deskY - 30, player.y)); // Can't cross desk

        if(dx !== 0) player.faceDir = dx > 0 ? 1 : -1;
        if(dx !== 0 || dy !== 0) player.frame += 0.2;

        // 2. Client Spawning (Pacing Logic)
        // 45 seconds = 45 * 60 = 2700 frames
        let spawnTime = 2700; 
        if(state.level > 1) spawnTime = 900; // 15s
        if(state.level > 2) spawnTime = 400; // 7s
        
        if(state.frame % spawnTime === 0 && clients.length < 3) {
            spawnClient();
        }

        // 3. Client Patience
        clients.forEach((c, i) => {
            c.patience -= (0.05 + (state.level * 0.02)); // Slow decay
            if(c.patience <= 0) {
                clients.splice(i, 1);
                state.patience -= 20;
                Audio.wompWomp();
                spawnParticle(c.x, c.y, "ü§¨", "red");
                checkGameOver();
            }
        });

        // 4. Interactions
        if(keys.space && !spaceLocked) {
            checkInteraction();
            spaceLocked = true;
        }

        updateHUD();
    }

    function spawnClient() {
        // Pick task
        const t = TASKS[Math.floor(Math.random() * TASKS.length)];
        // Position evenly
        const xPos = 150 + (clients.length * 200);
        
        clients.push({
            x: xPos, y: deskY + 20, w: 50, h: 60,
            task: t, patience: 100, maxP: 100
        });
        Audio.vineBoom(); // Sound effect
    }

    function checkInteraction() {
        // Cabinets
        for(let cab of state.map) {
            if(dist(player, cab) < 90) {
                player.holding = cab.task;
                spawnParticle(player.x, player.y - 60, "üìÇ", "white");
                Audio.playTone(300, 'square', 0.1);
                return;
            }
        }
        
        // Trash
        if(dist(player, trashBin) < 70) {
            if(player.holding) {
                player.holding = null;
                Audio.yeet();
                spawnParticle(trashBin.x, trashBin.y-50, "üóëÔ∏è", "gray");
            }
            return;
        }

        // Clients
        for(let i=0; i<clients.length; i++) {
            let c = clients[i];
            // Distance check modified because they are on opposite sides of desk
            let d = Math.hypot(player.x - c.x, player.y - (c.y - 60)); 
            
            if(d < 100) {
                if(player.holding && player.holding.id === c.task.id) {
                    // Serve
                    clients.splice(i, 1);
                    state.score++;
                    state.patience = Math.min(100, state.patience + 10);
                    player.holding = null;
                    Audio.yippee();
                    spawnParticle(c.x, c.y - 100, "‚úÖ", "#00b894");
                    
                    if(state.score >= state.goal) {
                        state.phase = 'LEVEL_DONE';
                        document.getElementById('level-screen').classList.remove('hidden');
                    }
                    return;
                } else if (player.holding) {
                    // Wrong
                    Audio.wompWomp();
                    spawnParticle(c.x, c.y - 100, "‚ùå", "red");
                    state.patience -= 10;
                }
            }
        }
    }

    function checkGameOver() {
        if(state.patience <= 0) {
            state.phase = 'GAMEOVER';
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
    }

    function updateHUD() {
        document.getElementById('level-display').innerText = state.level;
        document.getElementById('served-display').innerText = state.score;
        document.getElementById('goal-display').innerText = state.goal;
        document.getElementById('lives-display').innerText = Math.floor(state.patience) + '%';
    }

    function spawnParticle(x, y, txt, col) {
        particles.push({x, y, txt, col, life: 50});
    }

    function dist(o1, o2) {
        return Math.hypot((o1.x+o1.w/2) - (o2.x+o2.w/2), (o1.y+o1.h/2) - (o2.y+o2.h/2));
    }

    // --- RENDERER ---
    function draw() {
        ctx.clearRect(0, 0, 900, 650);

        // 1. Room Background
        // Walls
        ctx.fillStyle = "#b2bec3";
        ctx.fillRect(0, 0, 900, 150);
        // Floor
        ctx.fillStyle = "#dfe6e9";
        ctx.fillRect(0, 150, 900, 500);
        
        // Windows
        drawWindow(100, 30);
        drawWindow(650, 30);

        // Plants
        drawPlant(20, 120);
        drawPlant(840, 120);

        // 2. Cabinets (Behind Player)
        state.map.forEach(c => {
            // Draw cabinet body
            ctx.fillStyle = state.phase === 'MEMORIZE' ? c.task.color : '#636e72'; // Color or Dark Grey
            strokeRect(c.x, c.y, c.w, c.h);
            
            // Drawers
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(c.x+10, c.y+10, c.w-20, 20);
            ctx.fillRect(c.x+10, c.y+50, c.w-20, 20);
            ctx.fillRect(c.x+10, c.y+90, c.w-20, 20);
            
            if(state.phase === 'MEMORIZE') {
                ctx.fillStyle = "black";
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.fillText(c.task.icon, c.x + c.w/2, c.y - 15);
            }
        });
        
        // Meeting Table (Middle Decor)
        ctx.fillStyle = "#fdcb6e";
        strokeRect(350, 250, 200, 80);
        ctx.fillStyle = "rgba(0,0,0,0.1)";
        ctx.beginPath(); ctx.arc(380, 290, 20, 0, Math.PI*2); ctx.fill(); // Mug stains
        ctx.beginPath(); ctx.arc(500, 270, 10, 0, Math.PI*2); ctx.fill();

        // 3. Player
        drawPlayer(player);

        // 4. Reception Desk (The "Grey Wall") 
        // We draw this BEHIND the clients now? No, Clients are AT the desk.
        // Let's draw the desk body.
        ctx.fillStyle = "#d63031"; // Red desk top? No, Wood.
        ctx.fillStyle = "#e17055";
        strokeRect(0, deskY, 900, 150);
        
        // 5. Trash Bin
        ctx.fillStyle = "#636e72";
        strokeRect(trashBin.x, trashBin.y, trashBin.w, trashBin.h);
        ctx.fillStyle = "white"; ctx.font="10px Arial"; ctx.fillText("TRASH", trashBin.x+5, trashBin.y+30);

        // 6. Clients (In Front of Desk)
        clients.forEach(drawClient);

        // 7. Particles
        particles.forEach((p, i) => {
            ctx.fillStyle = p.col;
            ctx.font = "40px Arial";
            ctx.fillText(p.txt, p.x, p.y);
            p.y -= 1; p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        });
    }

    function strokeRect(x, y, w, h) {
        ctx.beginPath(); ctx.rect(x, y, w, h); ctx.fill();
        ctx.lineWidth = 4; ctx.strokeStyle = "black"; ctx.stroke();
    }

    function drawWindow(x, y) {
        ctx.fillStyle = "#74b9ff"; // Sky
        strokeRect(x, y, 150, 80);
        ctx.strokeStyle = "white"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(x+75, y); ctx.lineTo(x+75, y+80); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, y+40); ctx.lineTo(x+150, y+40); ctx.stroke();
        // Sun
        ctx.fillStyle = "#ffeaa7";
        ctx.beginPath(); ctx.arc(x+120, y+20, 15, 0, Math.PI*2); ctx.fill();
    }

    function drawPlant(x, y) {
        // Pot
        ctx.fillStyle = "#e17055";
        strokeRect(x, y+20, 40, 40);
        // Greenery
        ctx.fillStyle = "#00b894";
        ctx.beginPath(); ctx.arc(x+20, y+10, 25, 0, Math.PI*2); ctx.fill(); 
        ctx.strokeStyle="black"; ctx.stroke();
    }

    function drawPlayer(p) {
        let bob = Math.sin(p.frame) * 4;
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath(); ctx.ellipse(p.x + p.w/2, p.y + p.h - 5, 20, 8, 0, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = "#0984e3"; // Blue Suit
        strokeRect(p.x, p.y + bob, p.w, p.h);
        
        // Head
        ctx.fillStyle = "#ffeaa7";
        ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y - 10 + bob, 25, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "black"; ctx.stroke();
        
        // Eyes
        ctx.fillStyle = "black";
        let off = p.faceDir * 6;
        ctx.beginPath(); ctx.arc(p.x + p.w/2 + off - 6, p.y - 10 + bob, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(p.x + p.w/2 + off + 6, p.y - 10 + bob, 3, 0, Math.PI*2); ctx.fill();

        // Holding
        if(p.holding) {
            ctx.fillStyle = p.holding.color;
            strokeRect(p.x + 10 + (p.faceDir*10), p.y + 20 + bob, 25, 30);
            ctx.fillStyle = "black"; ctx.font="20px Arial";
            ctx.fillText(p.holding.icon, p.x + 12 + (p.faceDir*10), p.y + 42 + bob);
        }
    }

    function drawClient(c) {
        let bob = Math.sin(state.frame * 0.1) * 3;
        
        // They stand "on top" of the desk visually
        // Body
        ctx.fillStyle = c.task.color; // Shirt matches request color? No that makes it too easy.
        ctx.fillStyle = "#e84393"; // Pink shirt
        strokeRect(c.x, c.y + bob, c.w, c.h);
        
        // Head
        ctx.fillStyle = "#ff7675"; // Skin
        ctx.beginPath(); ctx.arc(c.x + c.w/2, c.y - 15 + bob, 25, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle="black"; ctx.stroke();
        
        // Face
        ctx.fillStyle = "black";
        ctx.beginPath(); ctx.arc(c.x + 15, c.y - 15 + bob, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(c.x + 35, c.y - 15 + bob, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(c.x + 20, c.y + 0 + bob); ctx.lineTo(c.x + 30, c.y + 0 + bob); ctx.stroke(); // Mouth

        // Thought Bubble (High up)
        ctx.fillStyle = "white";
        ctx.beginPath(); ctx.ellipse(c.x + 80, c.y - 50 + bob, 40, 30, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle="black"; ctx.stroke();
        
        // Icon
        ctx.fillStyle = "black"; ctx.font="30px Arial";
        ctx.textAlign = "center";
        ctx.fillText(c.task.icon, c.x + 80, c.y - 40 + bob);
        
        // Patience Bar
        ctx.fillStyle = "white";
        strokeRect(c.x - 10, c.y + 70, 70, 10);
        ctx.fillStyle = c.patience < 30 ? "red" : "#00b894";
        ctx.fillRect(c.x - 9, c.y + 71, 68 * (c.patience/100), 8);
    }

    init();

</script>
</body>
</html>